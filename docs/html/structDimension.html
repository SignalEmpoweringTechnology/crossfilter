<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppCrossFilter: Dimension&lt; V, T, isIterable &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CppCrossFilter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structDimension-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dimension&lt; V, T, isIterable &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Dimension&lt; V, T, isIterable &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structDimension.png" usemap="#Dimension_3C_20V_2C_20T_2C_20isIterable_20_3E_map" alt=""/>
  <map id="Dimension_3C_20V_2C_20T_2C_20isIterable_20_3E_map" name="Dimension_3C_20V_2C_20T_2C_20isIterable_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8fd701844dc14804ee1201cbde6216a5"><td class="memItemLeft" align="right" valign="top"><a id="a8fd701844dc14804ee1201cbde6216a5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type_t</b> = typename DimensionImpl&lt; V, T, isIterable &gt;::value_type_t</td></tr>
<tr class="separator:a8fd701844dc14804ee1201cbde6216a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff0b638823fed3d27fb6b16b2ce689"><td class="memItemLeft" align="right" valign="top"><a id="accff0b638823fed3d27fb6b16b2ce689"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>field_type_t</b> = typename DimensionImpl&lt; V, T, isIterable &gt;::field_type_t</td></tr>
<tr class="separator:accff0b638823fed3d27fb6b16b2ce689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ec6c9b96414405a4c06bb6933273f"><td class="memItemLeft" align="right" valign="top"><a id="a385ec6c9b96414405a4c06bb6933273f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>record_type_t</b> = typename DimensionImpl&lt; V, T, isIterable &gt;::record_type_t</td></tr>
<tr class="separator:a385ec6c9b96414405a4c06bb6933273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cd16451bae9efe967f1b9a39977dc6"><td class="memItemLeft" align="right" valign="top"><a id="ac5cd16451bae9efe967f1b9a39977dc6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type_t</b> = <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;</td></tr>
<tr class="separator:ac5cd16451bae9efe967f1b9a39977dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcb6e221c1cd2ed6308f2c9a6b0af97"><td class="memItemLeft" align="right" valign="top"><a id="a4bcb6e221c1cd2ed6308f2c9a6b0af97"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>base_type_t</b> = DimensionImpl&lt; V, T, isIterable &gt;</td></tr>
<tr class="separator:a4bcb6e221c1cd2ed6308f2c9a6b0af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c3421a05b78cf42a94c79fa8f234fd"><td class="memItemLeft" align="right" valign="top"><a id="ad4c3421a05b78cf42a94c79fa8f234fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>connection_type_t</b> = typename DimensionImpl&lt; V, T, isIterable &gt;::connection_type_t</td></tr>
<tr class="separator:ad4c3421a05b78cf42a94c79fa8f234fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d06aebb7a71f579ccfb2ac30f6091cc"><td class="memTemplParams" colspan="2"><a id="a2d06aebb7a71f579ccfb2ac30f6091cc"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a2d06aebb7a71f579ccfb2ac30f6091cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>signal_type_t</b> = typename DimensionImpl&lt; V, T, isIterable &gt;::template signal_type_t&lt; F &gt;</td></tr>
<tr class="separator:a2d06aebb7a71f579ccfb2ac30f6091cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af70acf63529bbc66c7263faa75b9eec9"><td class="memItemLeft" align="right" valign="top"><a id="af70acf63529bbc66c7263faa75b9eec9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Dimension</b> (CrossFilterImpl&lt; T &gt; *cf, std::tuple&lt; std::size_t, int &gt; filterPos_, std::function&lt; field_type_t(const record_type_t &amp;)&gt; getter_)</td></tr>
<tr class="separator:af70acf63529bbc66c7263faa75b9eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a33ec960b4a3748fb279d098bcefa3a"><td class="memItemLeft" align="right" valign="top"><a id="a8a33ec960b4a3748fb279d098bcefa3a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Dimension</b> (<a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt; &amp;&amp;dim)</td></tr>
<tr class="separator:a8a33ec960b4a3748fb279d098bcefa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6f007071060becfa2e1606192a783"><td class="memItemLeft" align="right" valign="top"><a id="a93f6f007071060becfa2e1606192a783"></a>
<a class="el" href="structDimension.html">Dimension</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structDimension.html">Dimension</a> &amp;&amp;dim)</td></tr>
<tr class="separator:a93f6f007071060becfa2e1606192a783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e88e43e86c1462bb47e0fee4ef86f7"><td class="memItemLeft" align="right" valign="top"><a id="af4e88e43e86c1462bb47e0fee4ef86f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dispose</b> ()</td></tr>
<tr class="separator:af4e88e43e86c1462bb47e0fee4ef86f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cd49201ec0e0a5caf80d152c1ff008"><td class="memItemLeft" align="right" valign="top"><a id="a52cd49201ec0e0a5caf80d152c1ff008"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getOffset</b> () const</td></tr>
<tr class="separator:a52cd49201ec0e0a5caf80d152c1ff008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d76a6ebc83a3f433a52dc6b89da79e6"><td class="memItemLeft" align="right" valign="top"><a id="a9d76a6ebc83a3f433a52dc6b89da79e6"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getBitIndex</b> () const</td></tr>
<tr class="separator:a9d76a6ebc83a3f433a52dc6b89da79e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc080344990842cb0e5e16e4114e46f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a5cc080344990842cb0e5e16e4114e46f">filterRange</a> (const value_type_t &amp;left, const value_type_t &amp;right)</td></tr>
<tr class="separator:a5cc080344990842cb0e5e16e4114e46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18746ebe68fe9cedd606d9aebe6cf2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#ab18746ebe68fe9cedd606d9aebe6cf2a">filterExact</a> (const value_type_t &amp;value)</td></tr>
<tr class="separator:ab18746ebe68fe9cedd606d9aebe6cf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c651bfe32d9065d8647e1f6917badc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#ad8c651bfe32d9065d8647e1f6917badc">filterAll</a> ()</td></tr>
<tr class="separator:ad8c651bfe32d9065d8647e1f6917badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff9f164fcfc3fb7cce66c58fed05d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a17ff9f164fcfc3fb7cce66c58fed05d8">filterWithPredicate</a> (std::function&lt; bool(const value_type_t &amp;)&gt; <a class="el" href="structDimension.html#a6720b2cd8a14ee427b9433e3faab31fb">filterFunction</a>)</td></tr>
<tr class="separator:a17ff9f164fcfc3fb7cce66c58fed05d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6720b2cd8a14ee427b9433e3faab31fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a6720b2cd8a14ee427b9433e3faab31fb">filterFunction</a> (std::function&lt; bool(const value_type_t &amp;)&gt; predicate)</td></tr>
<tr class="separator:a6720b2cd8a14ee427b9433e3faab31fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1827b70b7e312c7d828c9e080eb0f86d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a1827b70b7e312c7d828c9e080eb0f86d">filter</a> ()</td></tr>
<tr class="separator:a1827b70b7e312c7d828c9e080eb0f86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a590cf314cb65ce7542c686d570b83b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a5a590cf314cb65ce7542c686d570b83b">filter</a> (const value_type_t &amp;left, const value_type_t &amp;right)</td></tr>
<tr class="separator:a5a590cf314cb65ce7542c686d570b83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bd7c46e3b7f84c49ec130d0db79f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a31bd7c46e3b7f84c49ec130d0db79f5e">filter</a> (const value_type_t &amp;value)</td></tr>
<tr class="separator:a31bd7c46e3b7f84c49ec130d0db79f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007f68d093888013e0c8b89edd00d08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a007f68d093888013e0c8b89edd00d08b">filter</a> (std::function&lt; bool(const value_type_t &amp;)&gt; <a class="el" href="structDimension.html#a6720b2cd8a14ee427b9433e3faab31fb">filterFunction</a>)</td></tr>
<tr class="separator:a007f68d093888013e0c8b89edd00d08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeaf5d455ce09c738d1fc1f8be50d50"><td class="memItemLeft" align="right" valign="top">std::vector&lt; record_type_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a6aeaf5d455ce09c738d1fc1f8be50d50">bottom</a> (int64_t k, int64_t bottom_offset=0)</td></tr>
<tr class="separator:a6aeaf5d455ce09c738d1fc1f8be50d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4546a8532b393f3740b61eab19ec11"><td class="memItemLeft" align="right" valign="top">std::vector&lt; record_type_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#a8c4546a8532b393f3740b61eab19ec11">top</a> (int64_t k, int64_t top_offset=0)</td></tr>
<tr class="separator:a8c4546a8532b393f3740b61eab19ec11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299780d30139fec74dfbdfd98a5387a8"><td class="memTemplParams" colspan="2">template&lt;typename AddFunc , typename RemoveFunc , typename InitialFunc &gt; </td></tr>
<tr class="memitem:a299780d30139fec74dfbdfd98a5387a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#a299780d30139fec74dfbdfd98a5387a8">group</a> (AddFunc add_func_, RemoveFunc remove_func_, InitialFunc initial_func_) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; value_type_t, decltype(initial_func_()), <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td></tr>
<tr class="separator:a299780d30139fec74dfbdfd98a5387a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7896eaba5e68c498b129f5937308d89b"><td class="memTemplParams" colspan="2">template&lt;typename AddFunc , typename RemoveFunc , typename InitialFunc , typename KeyFunc &gt; </td></tr>
<tr class="memitem:a7896eaba5e68c498b129f5937308d89b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#a7896eaba5e68c498b129f5937308d89b">group</a> (AddFunc add_func_, RemoveFunc remove_func_, InitialFunc initial_func_, KeyFunc key) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; decltype(key(std::declval&lt; value_type_t &gt;())), decltype(initial_func_()), <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td></tr>
<tr class="separator:a7896eaba5e68c498b129f5937308d89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddd17f0622a5a9920518ec32c1a572c"><td class="memItemLeft" align="right" valign="top"><a id="a8ddd17f0622a5a9920518ec32c1a572c"></a>
<a class="el" href="structGroup.html">Group</a>&lt; value_type_t, std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>group</b> ()</td></tr>
<tr class="separator:a8ddd17f0622a5a9920518ec32c1a572c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb586f96985d57bc9126ec1386bd5694"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:afb586f96985d57bc9126ec1386bd5694"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#afb586f96985d57bc9126ec1386bd5694">group</a> (G key_) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; decltype(key_(std::declval&lt; value_type_t &gt;())), std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td></tr>
<tr class="separator:afb586f96985d57bc9126ec1386bd5694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc65ff722f7e3aa4b1513c069532d06"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a0cc65ff722f7e3aa4b1513c069532d06"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#a0cc65ff722f7e3aa4b1513c069532d06">groupReduceCount</a> (K key) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; decltype(key(std::declval&lt; value_type_t &gt;())), std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td></tr>
<tr class="separator:a0cc65ff722f7e3aa4b1513c069532d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c083059cb248baa027efc2427d066d"><td class="memTemplParams" colspan="2">template&lt;typename ValueFunc &gt; </td></tr>
<tr class="memitem:a86c083059cb248baa027efc2427d066d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#a86c083059cb248baa027efc2427d066d">groupReduceSum</a> (ValueFunc value) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; value_type_t, decltype(value(record_type_t())), <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td></tr>
<tr class="separator:a86c083059cb248baa027efc2427d066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0e5e0e423f2609856a4729ebc5f273"><td class="memTemplParams" colspan="2">template&lt;typename ValueFunc , typename KeyFunc &gt; </td></tr>
<tr class="memitem:afc0e5e0e423f2609856a4729ebc5f273"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#afc0e5e0e423f2609856a4729ebc5f273">groupReduceSum</a> (ValueFunc value, KeyFunc key) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; decltype(key(std::declval&lt; value_type_t &gt;())), decltype(value(std::declval&lt; record_type_t &gt;())), <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td></tr>
<tr class="separator:afc0e5e0e423f2609856a4729ebc5f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519547beab6069c34da2ec1b7ed5ce0d"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a519547beab6069c34da2ec1b7ed5ce0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structGroup.html">Group</a>&lt; std::size_t, R, <a class="el" href="structDimension.html">this_type_t</a>, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#a519547beab6069c34da2ec1b7ed5ce0d">groupAll</a> (std::function&lt; R(R &amp;, const record_type_t &amp;, bool)&gt; add_func_, std::function&lt; R(R &amp;, const record_type_t &amp;, bool)&gt; remove_func_, std::function&lt; R()&gt; initial_func_)</td></tr>
<tr class="separator:a519547beab6069c34da2ec1b7ed5ce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbfda693f81ca8c785164d84907dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGroup.html">Group</a>&lt; std::size_t, std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDimension.html#ad4dbfda693f81ca8c785164d84907dcc">groupAllReduceCount</a> ()</td></tr>
<tr class="separator:ad4dbfda693f81ca8c785164d84907dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae778ae969e2f918422cd347c71e5b25"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:aae778ae969e2f918422cd347c71e5b25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#aae778ae969e2f918422cd347c71e5b25">groupAllReduceSum</a> (G value) -&gt; <a class="el" href="structGroup.html">Group</a>&lt; std::size_t, decltype(value(record_type_t())), <a class="el" href="structDimension.html">this_type_t</a>, true &gt;</td></tr>
<tr class="separator:aae778ae969e2f918422cd347c71e5b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c6238f5f9be15b064a3b49b921258"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a9b7c6238f5f9be15b064a3b49b921258"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structGroup.html">Group</a>&lt; std::size_t, R, <a class="el" href="structDimension.html">this_type_t</a>, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDimension.html#a9b7c6238f5f9be15b064a3b49b921258">groupAll</a> ()</td></tr>
<tr class="separator:a9b7c6238f5f9be15b064a3b49b921258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afb68d401a5227413705f10d2c0f460d3"><td class="memItemLeft" align="right" valign="top"><a id="afb68d401a5227413705f10d2c0f460d3"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>getIsIterable</b> ()</td></tr>
<tr class="separator:afb68d401a5227413705f10d2c0f460d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6aeaf5d455ce09c738d1fc1f8be50d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aeaf5d455ce09c738d1fc1f8be50d50">&#9670;&nbsp;</a></span>bottom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;record_type_t&gt; <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::bottom </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>bottom_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new array containing the bottom k records, according to the natural order of this dimension. The returned array is sorted by ascending natural order. This method intersects the crossfilter's current filters, returning only records that satisfy every active filter (including this dimension's filter). Optionally, retrieve k records offset by offset </p>

</div>
</div>
<a id="a1827b70b7e312c7d828c9e080eb0f86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1827b70b7e312c7d828c9e080eb0f86d">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears any filters on this dimension </p>

</div>
</div>
<a id="a5a590cf314cb65ce7542c686d570b83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a590cf314cb65ce7542c686d570b83b">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const value_type_t &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type_t &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filters records such that this dimension's value is greater than or equal to left, and less than right. </p>

</div>
</div>
<a id="a31bd7c46e3b7f84c49ec130d0db79f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bd7c46e3b7f84c49ec130d0db79f5e">&#9670;&nbsp;</a></span>filter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const value_type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filters records such that this dimension's value equals value </p>

</div>
</div>
<a id="a007f68d093888013e0c8b89edd00d08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007f68d093888013e0c8b89edd00d08b">&#9670;&nbsp;</a></span>filter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const value_type_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>filterFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filters records such that the specified function returns truthy when called with this dimension's value </p>

</div>
</div>
<a id="ad8c651bfe32d9065d8647e1f6917badc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c651bfe32d9065d8647e1f6917badc">&#9670;&nbsp;</a></span>filterAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filterAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears any filters on this dimension </p>

</div>
</div>
<a id="ab18746ebe68fe9cedd606d9aebe6cf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18746ebe68fe9cedd606d9aebe6cf2a">&#9670;&nbsp;</a></span>filterExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filterExact </td>
          <td>(</td>
          <td class="paramtype">const value_type_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters records such that this dimension's value equals value </p>

</div>
</div>
<a id="a6720b2cd8a14ee427b9433e3faab31fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6720b2cd8a14ee427b9433e3faab31fb">&#9670;&nbsp;</a></span>filterFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filterFunction </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const value_type_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters records such that the specified function returns truthy when called with this dimension's value </p>

</div>
</div>
<a id="a5cc080344990842cb0e5e16e4114e46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc080344990842cb0e5e16e4114e46f">&#9670;&nbsp;</a></span>filterRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filterRange </td>
          <td>(</td>
          <td class="paramtype">const value_type_t &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type_t &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters records such that this dimension's value is greater than or equal to left, and less than right. </p>

</div>
</div>
<a id="a17ff9f164fcfc3fb7cce66c58fed05d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ff9f164fcfc3fb7cce66c58fed05d8">&#9670;&nbsp;</a></span>filterWithPredicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::filterWithPredicate </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const value_type_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>filterFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters records such that the specified function returns truthy when called with this dimension's value </p>

</div>
</div>
<a id="a299780d30139fec74dfbdfd98a5387a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299780d30139fec74dfbdfd98a5387a8">&#9670;&nbsp;</a></span>group() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename AddFunc , typename RemoveFunc , typename InitialFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::group </td>
          <td>(</td>
          <td class="paramtype">AddFunc&#160;</td>
          <td class="paramname"><em>add_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemoveFunc&#160;</td>
          <td class="paramname"><em>remove_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitialFunc&#160;</td>
          <td class="paramname"><em>initial_func_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structGroup.html">Group</a>&lt;value_type_t,
               decltype(initial_func_()), <a class="el" href="structDimension.html">this_type_t</a>, false&gt;  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new grouping for the given dimension, according to the specified reduce functions. </p>

</div>
</div>
<a id="a7896eaba5e68c498b129f5937308d89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896eaba5e68c498b129f5937308d89b">&#9670;&nbsp;</a></span>group() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename AddFunc , typename RemoveFunc , typename InitialFunc , typename KeyFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::group </td>
          <td>(</td>
          <td class="paramtype">AddFunc&#160;</td>
          <td class="paramname"><em>add_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemoveFunc&#160;</td>
          <td class="paramname"><em>remove_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitialFunc&#160;</td>
          <td class="paramname"><em>initial_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyFunc&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structGroup.html">Group</a>&lt; decltype(key(std::declval&lt; value_type_t &gt;())), decltype(initial_func_()), <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new grouping for the given dimension, according to the specified reduce and key functions. </p>

</div>
</div>
<a id="afb586f96985d57bc9126ec1386bd5694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb586f96985d57bc9126ec1386bd5694">&#9670;&nbsp;</a></span>group() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::group </td>
          <td>(</td>
          <td class="paramtype">G&#160;</td>
          <td class="paramname"><em>key_</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structGroup.html">Group</a>&lt;decltype(key_(std::declval&lt;value_type_t&gt;())),
                                std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, false&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new grouping for the given dimension to reduce elements by count </p>

</div>
</div>
<a id="a519547beab6069c34da2ec1b7ed5ce0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519547beab6069c34da2ec1b7ed5ce0d">&#9670;&nbsp;</a></span>groupAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGroup.html">Group</a>&lt;std::size_t, R, <a class="el" href="structDimension.html">this_type_t</a>, true&gt; <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupAll </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; R(R &amp;, const record_type_t &amp;, bool)&gt;&#160;</td>
          <td class="paramname"><em>add_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; R(R &amp;, const record_type_t &amp;, bool)&gt;&#160;</td>
          <td class="paramname"><em>remove_func_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>initial_func_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for grouping all records into a single group. </p>

</div>
</div>
<a id="a9b7c6238f5f9be15b064a3b49b921258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c6238f5f9be15b064a3b49b921258">&#9670;&nbsp;</a></span>groupAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGroup.html">Group</a>&lt;std::size_t, R, <a class="el" href="structDimension.html">this_type_t</a>, true&gt; <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <a class="el" href="structDimension.html#ad4dbfda693f81ca8c785164d84907dcc">groupAllReduceCount()</a> </p>

</div>
</div>
<a id="ad4dbfda693f81ca8c785164d84907dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbfda693f81ca8c785164d84907dcc">&#9670;&nbsp;</a></span>groupAllReduceCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGroup.html">Group</a>&lt;std::size_t, std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, true&gt; <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupAllReduceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for grouping all records into a single group to reduce by count </p>

</div>
</div>
<a id="aae778ae969e2f918422cd347c71e5b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae778ae969e2f918422cd347c71e5b25">&#9670;&nbsp;</a></span>groupAllReduceSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupAllReduceSum </td>
          <td>(</td>
          <td class="paramtype">G&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structGroup.html">Group</a>&lt; std::size_t, decltype(value(record_type_t())), <a class="el" href="structDimension.html">this_type_t</a>, true &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for grouping all records into a single group to reduce by sum </p>

</div>
</div>
<a id="a0cc65ff722f7e3aa4b1513c069532d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc65ff722f7e3aa4b1513c069532d06">&#9670;&nbsp;</a></span>groupReduceCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupReduceCount </td>
          <td>(</td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structGroup.html">Group</a>&lt; decltype(key(std::declval&lt; value_type_t &gt;())), std::size_t, <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new grouping for the given dimension to reduce elements by count </p>

</div>
</div>
<a id="a86c083059cb248baa027efc2427d066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c083059cb248baa027efc2427d066d">&#9670;&nbsp;</a></span>groupReduceSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename ValueFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupReduceSum </td>
          <td>(</td>
          <td class="paramtype">ValueFunc&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structGroup.html">Group</a>&lt;value_type_t, decltype(value(record_type_t())), <a class="el" href="structDimension.html">this_type_t</a>, false&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new grouping for the given dimension to reduce elements by sum </p>

</div>
</div>
<a id="afc0e5e0e423f2609856a4729ebc5f273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0e5e0e423f2609856a4729ebc5f273">&#9670;&nbsp;</a></span>groupReduceSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
<div class="memtemplate">
template&lt;typename ValueFunc , typename KeyFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::groupReduceSum </td>
          <td>(</td>
          <td class="paramtype">ValueFunc&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyFunc&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structGroup.html">Group</a>&lt; decltype(key(std::declval&lt; value_type_t &gt;())), decltype(value(std::declval&lt; record_type_t &gt;())), <a class="el" href="structDimension.html">this_type_t</a>, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new grouping for the given dimension to reduce elements by sum </p>

</div>
</div>
<a id="a8c4546a8532b393f3740b61eab19ec11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4546a8532b393f3740b61eab19ec11">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T , bool isIterable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;record_type_t&gt; <a class="el" href="structDimension.html">Dimension</a>&lt; V, T, isIterable &gt;::top </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>top_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new array containing the top k records, according to the natural order of this dimension. The returned array is sorted by descending natural order. This method intersects the crossfilter's current filters, returning only records that satisfy every active filter (including this dimension's filter). Optionally, retrieve k records offset by offset (records offset - offset + k - 1) </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/detail/<a class="el" href="crossfilter_8hpp_source.html">crossfilter.hpp</a></li>
<li>include/detail/<a class="el" href="dimension_8hpp_source.html">dimension.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
